/** WRITE YOUR TIPS IN THIS FILE **/
1. You need to made a 3d matrix which the dimension is storage number x state height x state width, which is only made once for each sokoban problem.  This will save a lot of time.

2. Use a BFS algorithm that start from one storage coordinate and with each move the cost add one, the cost is put into the storage's corresponding matrix entry.  Then repeat for each matrix.

3. I used the matrix to calculate the cost between each space to storage and the coordinate in the state with obstacles are set to a really large number in the matrix, but the storage(which is the start point) is set to a large number too, so we won't go back to storage which would result in a loop when using BFS.

4. After the matrix is made, with each call to the heristic function, we only loop through the box the find the right storage(if there is restrictions), then go to that storage's 2d matrix from the 3d matrix, to find the box's cost.

5. Need to watch out for the storage when looping through the box.  When the box is on a storage, the box's cost is the number we set for storage, which is really large.  Because we are looping through storage in the for loop for box to find the minimum cost, if a cost we find for the box is equal to the number we set for the storage, the box is at destination, in that case, we would set the current cost to 0.

1.We have all of the information we need. Manahttan let's us simplify things by considering a case where
a storage may store more than one box satisfying its own restriction. ie a storage can only store boxes with
certrain labels. Hence, consider the three information only: box location, storage location and restriction.




2.Using the three information from above, find all the possible moves each box can make to be stored in its own
proper storage space.

3.To figure out where each box is able to be stored due to restriction, we may store the box_labels into a different
array and use them later to see if any restriction was imposed. If not, we may store the boxes anywhere we like.

4.To minimize the cost, geometrically this will become equivalent to using the storage space where the L2 norm, 
or the distance to that box to the storage space of interest is minimal. This is simple pythagorus.

5.Utlize this the information by considering exactly which box was moved to which storage space giving the minimal
by using a loop and terminate by adding all the |delta(x)| and |delta(y)| distance giving the Manhattan.

1. The first step in developing a good sokoban heuristic is to recognise where all the obstacles are in an given state. You want to store/keep track of where the obstacles are in some way early in your heuristic function.

2. You need to be able to test whether or not a box is in a corner that is not a storage point. The reason for this being that when a box ends up in a corner, it cannot be moved again. Hence, if the box is in a corner and that corner is not a storage point, you should immediately set your heuristic function to unsolvable and move on to the next step in the search tree.

3. In addition to calculating the Manhattan distance between boxes and storage points, you should also calculate the Manhattan distance between boxes and the robot. This is necessary to a good heuristic, because the position of the robot greatly affects the optimal solution to any state.

4. You should only look at the distance between one box and one storage point/one robot at a time. Do not try to calculate distances between multiple items.

5. Make sure to base your heuristic on simple/minimal distance calculations in certain scenarios. Do not add unnecessary and complex computation, such as the Hungarian Algorithm, to your heuristic. This will only add complexity/time to your sokoban solver, meaning even simple puzzles could require a lot of processing time to solve.
