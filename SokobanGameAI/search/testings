from solution import *
from search import * #for search engines
from sokoban import SokobanState, Direction, PROBLEMS #for Sokoban specific classes and problems

def main():
    ss = SokobanState("START", 0, None, 5, 5, # dimensions
                 ((2, 1), (2, 3)), #robots
                 frozenset(((4, 0), (4, 2), (3, 1), (3, 3))), #boxes
                 frozenset(((0, 0), (0, 4), (4, 0), (4, 4))), #storage
                 frozenset(((1, 0), (2, 0), (3, 0), (1, 4), (2, 4), (3, 4))) #obstacles
                 )
    ss.print_state()
    print(heur_alternate(ss))
    # print(is_horizontal_adjacent(list(ss.boxes)[0], list(ss.boxes)[1]))
    return


##Temporary storage
def test_inner_func(a, b):
    def inner_func():
        print('a is', a, 'b is', b)
        return a+b
    print('Result is', inner_func())

def anytime_weighted_astar(initial_state, heur_fn, weight=1., timebound = 10):
#IMPLEMENT
    '''Provides an implementation of anytime weighted a-star, as described in the HW1 handout'''
    '''INPUT: a sokoban state that represents the start state and a timebound (number of seconds)'''
    '''OUTPUT: A goal state (if a goal is found), else False'''
    '''implementation of weighted astar algorithm'''
    tic = os.times()[0]
    time, weight = 0, 2.1
    iter = 0

    se = SearchEngine('astar', 'full') # astar data structure to store the frontier, with full cycle checking
    se.init_search(initial_state, goal_fn=sokoban_goal_state, heur_fn=heur_alternate, fval_function=(lambda sN: fval_function(sN, weight)))

    try:
        # Initiate the search results with the basic gbf
        final = se.search(timebound)
        gval = final.gval
    except: # If even the basic one can't find a solution, no need to continue
        final = False
    time += os.times()[0] - tic

    while time < timebound and weight > 0 and not se.open.empty():
        tic = os.times()[0]
        if final == False:
            weight *= 2
        else:
            weight /= 4
        try:
            costbound = (gval, float('inf'), float('inf')) # hval is not constraint, gval is constraint by the past optimal g
            new_final = se.search(timebound, costbound)
            new_gval = new_final.gval
            if new_gval < gval:
                final, gval = new_final, new_gval
                final_weight = weight
        except:
            pass
        time += os.times()[0] - tic
        iter += 1

    print('Total iterations:', iter, 'Final weight:', weight)
    return final

if __name__ == '__main__':
    main()
    # test_inner_func(1, 2)
